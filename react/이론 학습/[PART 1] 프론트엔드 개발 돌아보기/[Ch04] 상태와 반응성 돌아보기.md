# Ch.04 상태와 반응성 돌아보기

## 학습 목표
- 클라이언트와 서버 상태를 설명할 수 있다.
- 프론트엔드에서 상태와 반응성이 하는 역할 이해
- 애플리케이션 아키텍처 살펴보기
- 관찰자 패턴을 통한 반응성 구현 이해
- MVVM과 관찰자 패턴을 활용한 미니 프레임워크 구현

## 핵심 키워드 정리

| 키워드 | 정의 | 특징 / 역할 |
|--------|------|-------------|
| 상태(State) | 시스템이나 애플리케이션이 특정 시점에 가지는 데이터와 조건 | 서버 상태와 클라이언트 상태로 구분, UI와 로직 결정 |
| 반응성(Reactivity) | 상태 변경을 감지하고 자동으로 UI를 업데이트하는 능력 | 수동 DOM 조작 필요 없음, 개발 생산성 향상 |
| MVC 패턴 | Model-View-Controller 패턴 | 모델(데이터) / 뷰(UI) / 컨트롤러(중재자)로 분리, 전통적 웹 아키텍처 |
| MVVM 패턴 | Model-View-ViewModel 패턴 | 뷰와 모델 사이에 ViewModel을 둬서 양방향 데이터 흐름 지원, DOM 직접 제어 불필요 |
| 관찰자 패턴(Observer) | 상태 변경 시 구독자에게 자동 알림 | 발행자(Publisher)와 구독자(Subscriber) 구조, 이벤트 기반 업데이트 |
| 양방향 바인딩 | 뷰와 뷰모델의 데이터가 서로 자동 동기화 | 뷰 변경 → 모델 자동 업데이트, 코드 간소화, 추적 어려움, Angular/Vue |
| 단방향 바인딩 | 데이터 흐름이 뷰모델 → 뷰로만 진행 | 상태 변경 시 UI만 업데이트, 디버깅 용이, React 기본 방식 |

---

## 4.1 반응성과 상태의 중요성
- **질문**
  - 어떤 데이터를 상태로 만들 것인가?
  - 컴포넌트 간 상태를 어떻게 공유하고 전달할 것인가?
- 상태와 반응성의 원리를 이해하면 단순 기능 구현을 넘어 **애플리케이션 전체 데이터 흐름 설계** 가능
- MVC, MVVM 등 디자인 패턴 이해 → 프로젝트 성격에 맞는 상태 관리 전략 수립

---

## 4.2 상태와 설계 컴포넌트

### 상태 정의
> 특정 시점에 시스템이 가지는 조건이나 상황

- **서버 상태(Server State)**
  - DB 기반 데이터, 비즈니스 로직 가공 후 클라이언트에 전달
  - 예: 유저 정보, 게시글 목록
- **클라이언트 상태(Client State)**
  - 화면 표시용 데이터, UI 상호작용 상태
  - 예: 모달 열림/닫힘, 로딩 스피너

**검색 플로우 예시**

| 단계 | 클라이언트 | 서버 |
|------|------------|------|
| 1    | 검색 요청 + 로딩 UI 표시 | - |
| 2    | - | DB 조회 후 결과 전달 |
| 3    | 결과 UI 업데이트, 로딩 숨김 | - |

> **디자인 패턴**: UI와 데이터 관리를 효과적으로 설계하기 위한 검증된 방법  

---

### 4.2.1 View (UI, Presentation Layer)
- 화면 표시와 사용자 이벤트 처리 담당
- 상태 변경 시 자동 업데이트 (반응성)
- 역할: 데이터 표시 + 이벤트 감지 + 상태 변경 전달

### 4.2.2 Model (데이터 & 비즈니스 로직)
- 애플리케이션 데이터 관리
- 프론트엔드: 클라이언트 상태 및 관리 로직
- 백엔드: DB 스키마, ORM, 도메인 규칙
- **주요 역할**
  1. 데이터 관리
  2. 비즈니스 로직 실행 (API 호출, 오류 처리 포함)

### 4.2.3 Mediator (중재자)
| 디자인 패턴 | 중재자 역할 |
|-------------|------------|
| MVC | Controller |
| MVP | Presenter |
| MVVM | ViewModel |
| Flux | Action + Store |

**중재자 역할**
1. 입력 처리 (뷰 → 이벤트)
2. 로직 실행 및 상태 변경 (모델 요청)
3. 데이터 가공 (뷰 표시용)
4. 로직 캡슐화 (뷰는 UI만 담당)

> 모던 프레임워크에서는 useState(), useReducer(), 이벤트 핸들러, JSX 등으로 통합 구현

---

## 4.3 반응성 구현

### 4.3.1 비반응성 MVC
- 모델 상태 변경 시 컨트롤러가 **직접 뷰 업데이트**
- 단점: 랜더링 누락 시 UI 최신 상태 반영 실패 → 버그 발생

### 4.3.2 MVC + 반응성
- 모델이 **자체적으로 상태 변경 알림**
- 구독자(컨트롤러/뷰)가 자동 업데이트 수행
- **관찰자 패턴(Observer Pattern)** 적용

---

## 4.4 관찰자 패턴

- **구성**
  - 발행자(Publisher): 상태 변화 알림
  - 구독자(Subscriber): 상태 변화 수신 후 작업 수행
- **동작**
  1. 구독자가 발행자 이벤트 구독
  2. 발행자가 상태 변경 시 모든 구독자 통지
  3. 구독자는 알림 받아 작업 수행

### 관찰자 패턴 핵심 인터페이스 예시

```ts
interface ObserverPattern<T> {
  /**
   * 구독 등록
   * 구독자는 자신의 콜백(listener)을 전달하여 발행자의 구독자 목록에 등록
   */
  subscribe(listener: (data: T) => void): void;

  /**
   * 상태 변경 통지
   * 등록된 모든 구독자에게 변경 사실과 최신 데이터를 전달
   */
  notify(data: T): void;

  /**
   * 구독 취소
   * 더 이상 알림을 받을 필요 없을 때 구독자 목록에서 자신을 제거
   * 데이터 누수를 방지
   */
  unsubscribe(listener: (data: T) => void): void;
}
```

### 관찰자 패턴 예시: Redux

- **스토어(Store)** = 발행자(Publisher)  
  - 상태를 관리하고, 상태 변경 시 구독자에게 알림
- **React 컴포넌트** = 구독자(Subscriber)  
  - 스토어를 구독하여 상태 변경 시 자동으로 리렌더링
- 동작 흐름
  1. 컴포넌트에서 액션(Action) 발생
  2. 스토어가 상태 변경
  3. 스토어가 구독 중인 모든 컴포넌트에 변경 알림
  4. 컴포넌트가 자동으로 리렌더링

# 4.5 MVVM(Model-View-ViewModel) 패턴과 반응성

MVVM 패턴은 **View(유저 인터페이스)**와 **Model(데이터/비즈니스 로직)**을 분리하고, 그 사이를 **ViewModel**이라는 중재자를 통해 연결하는 패턴입니다.

- **유저 입력의 흐름:** `View → ViewModel → Model`  
- **상태 변경의 흐름:** `Model → ViewModel → View`  
- DOM을 직접 제어할 필요 없이 상태 기반으로 UI가 업데이트됩니다.

---

## 4.5.1 데이터 바인딩

데이터 바인딩은 **뷰와 뷰모델의 데이터를 자동으로 동기화**하는 메커니즘입니다.

| 바인딩 유형 | 데이터 흐름 | 특징 | 예시 |
|------------|-------------|------|------|
| 단방향 바인딩 | ViewModel → View | 상태 변경 시 UI 자동 업데이트, 디버깅 용이, 이벤트 핸들러 필요 | React (useState + onChange) |
| 양방향 바인딩 | ViewModel ↔ View | UI 변경 시 모델 자동 업데이트, 코드량 감소, 추적 어려움 | Angular `[(ngModel)]`, Vue `v-model` |

> ⚠️ 단방향 바인딩은 디버깅에 유리하지만 이벤트 핸들러를 매번 작성해야 함  
> ⚡ 양방향 바인딩은 코드가 간결하고 빠르게 개발 가능하지만 상태 변경 추적이 어려울 수 있음

---

## 4.5.3 바인더(Binder)

바인더는 **MVVM에서 View와 ViewModel 사이 상호작용의 핵심 엔진** 역할을 수행합니다.

### 바인더의 주요 역할

1. **DOM 스캔 및 초기 바인딩**  
   - 애플리케이션 시작 시 HTML 문서 스캔  
   - `data-bind`, `data-click` 등 속성을 가진 요소를 찾아 뷰모델의 데이터/메서드와 연결

2. **뷰모델 구독**  
   - 뷰모델의 `subscribe()` 호출  
   - 상태 변경 시 바인더가 자동으로 통지 받음

3. **뷰 업데이트**  
   - 상태 변경 통지를 받아 어떤 속성이 바뀌었는지 확인  
   - 연결된 DOM 요소의 내용을 업데이트

4. **뷰 이벤트 리스닝**  
   - `data-click`, `<input>` 등 이벤트 감지  
   - 이벤트 발생 시 연결된 뷰모델 메서드 호출

> ✅ 바인더를 통해 **뷰와 뷰모델은 각자의 책임에 집중**할 수 있어 코드 구조가 깔끔해짐

